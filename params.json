{"name":"Enliven","tagline":"Enlive next: faster, better, broader","body":"# Enliven [![Build Status](https://travis-ci.org/cgrand/enliven.png?branch=master)](https://travis-ci.org/cgrand/enliven)\r\n\r\nEnliven: a (not yet) continuous templating system.\r\n\r\n*WARNING* very wet paint\r\n\r\n## Enliven is the successor to Enlive\r\n\r\nEven dictionaries say so:\r\n\r\n> Enlive: To Enliven (Obs.)\r\n\r\nEnliven also stands for Enlive N(ext).\r\n\r\n### Not tied to HTML\r\n\r\nCurrently Enliven can template plain text (`enliven.text`) and html (`enliven.html`).\r\nThe HTML \"domain\" is even composite since it uses the text \"domain\" to template text nodes.\r\n\r\n### Simpler selectors\r\n\r\nSelectors are now functions from loc to locs. Most domains should expose a `sel` function to coerce\r\na domain specific selector (eg a CSS-selector in string or a regex) to a selector fn.\r\n\r\n### Parallel execution of transformations\r\n\r\nAll transformations occur at once for maximum declarativeness (and it enables good performance). It follows that two transformations can't work on the same node\r\nor on a node and one of its ancestors.\r\n\r\nThis constraint is heavily mitigated by infinite-resolution selectors and transformation-refined selectors.\r\n\r\n### Infinite-resolution selectors\r\n\r\nSelectors don't stop at nodes as specified in the DOM. Any node can be subdivided at will!\r\n\r\nFor example classes in a `class` attribute can be targeted independently. Each character of a text node can be transformed independently.\r\nYou can append/content/prepend on an element without conflicts!\r\n\r\nHowever this happens under the hood, see: \r\n\r\n```clj\r\n(at \r\n  \"div\" (class \"important\" :important)\r\n  \"div\" (class \"footnote\" :foot-note))\r\n```\r\n\r\nThose two transformations won't conflict because they refine their selector.\r\n\r\n### Point-free\r\n\r\nTemplates take a single argument which is the data model to render.\r\n\r\nTransformations don't take as arguments the actual values but keys or paths into the model.\r\n\r\n```clj\r\n=> ((static-template\r\n     (enliven.html.jsoup/parse \"<div>\")\r\n     \"div\" (content :sentence))\r\n     {:sentence \"Hello world\"})\r\n\"<html><head></head><body><div>Hello world</div></body></html>\"\r\n```\r\n\r\nSome transformations like `dup` introduces a new scope so that sub-transformation can only see\r\nthe current item.\r\n\r\n```clj\r\n=> ((static-template\r\n     (enliven.html.jsoup/parse \"<ul><li>\")\r\n     \"li\" (dup :todos \r\n            (content []))) ; [] is the empty path, so points to the whole value\r\n     {:todos [\"Laundry\" \"Walk the dog\"]})\r\n\"<html><head></head><body><ul><li>Laundry</li><li>Walk the dog</li></ul></body></html>\"\r\n```\r\n\r\n### It's fast\r\n\r\nGenerating a 5x5 table. (pr-str just dumps the 5*5 vector):\r\n* pr-str (24.5µs), \r\n* enliven (24.8µs), \r\n* hiccup (44.8µs), \r\n* enlive (130µs), \r\n* laser (1280µs).\r\n\r\nhttps://gist.github.com/cgrand/8471718\r\n\r\n## Dev details\r\n\r\n### Processing model\r\n\r\n1. Nodes are selected\r\n2. For each selected node, associated transformations are grounded -- this is where the nodes are refined to avoid conflicts. The result is a set of rules.\r\n3. A hierarchical plan is created from the rules.\r\n4. The plan can either be executed as is or \"compiled\".\r\n\r\n## License\r\n\r\nCopyright © 2014 Christophe Grand\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}